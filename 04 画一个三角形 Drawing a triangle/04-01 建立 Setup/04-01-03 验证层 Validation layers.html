<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>04-01-03 验证层</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../01 简介 Introduction.html">01 简介</a></li><li class="chapter-item expanded affix "><a href="../../02 概述 Overview.html">02 概述</a></li><li class="chapter-item expanded affix "><a href="../../03 开发环境 Development environment.html">03 开发环境</a></li><li class="chapter-item expanded affix "><li class="part-title">04 画一个三角形 Drawing a triangle</li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-05 重新创建交换链 Swap chain recreation.html"><strong aria-hidden="true">1.</strong> 04-05 重新创建交换链</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-01 建立 Setup/04-01-01 基本代码 Base code.html"><strong aria-hidden="true">2.</strong> 04-01-01 基本代码</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-01 建立 Setup/04-01-02 实例 Instance.html"><strong aria-hidden="true">3.</strong> 04-01-02 实例</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-01 建立 Setup/04-01-03 验证层 Validation layers.html" class="active"><strong aria-hidden="true">4.</strong> 04-01-03 验证层</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-01 建立 Setup/04-01-04 物理设备与队列家族 Physical devices and queue families.html"><strong aria-hidden="true">5.</strong> 04-01-04 物理设备与队列家族</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-01 建立 Setup/04-01-05 逻辑设备与队列 Logical device and queues.html"><strong aria-hidden="true">6.</strong> 04-01-05 逻辑设备与队列</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-02 显示 Presentation/04-02-01 表面 Window surface.html"><strong aria-hidden="true">7.</strong> 04-02-01 表面</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-02 显示 Presentation/04-02-02 交换链 Swap chain.html"><strong aria-hidden="true">8.</strong> 04-02-02 交换链</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-02 显示 Presentation/04-02-03 图像视图 Image views.html"><strong aria-hidden="true">9.</strong> 04-02-03 图像视图</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-03 图形管线基础 Graphics pipeline basics/04-03-01 简介 Introduction.html"><strong aria-hidden="true">10.</strong> 04-03-01 简介</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-03 图形管线基础 Graphics pipeline basics/04-03-02 着色器模块 Shader modules.html"><strong aria-hidden="true">11.</strong> 04-03-02 着色器模块</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-03 图形管线基础 Graphics pipeline basics/04-03-03 固定功能 Fixed functions.html"><strong aria-hidden="true">12.</strong> 04-03-03 固定功能</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-03 图形管线基础 Graphics pipeline basics/04-03-04 渲染过程 Render passes.html"><strong aria-hidden="true">13.</strong> 04-03-04 渲染过程</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-03 图形管线基础 Graphics pipeline basics/04-03-05 小结 Conclusion.html"><strong aria-hidden="true">14.</strong> 04-03-05 小结</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-04 绘制 Drawing/04-04-01 帧缓冲 Framebuffers.html"><strong aria-hidden="true">15.</strong> 04-04-01 帧缓冲</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-04 绘制 Drawing/04-04-02 命令缓冲 Command buffers.html"><strong aria-hidden="true">16.</strong> 04-04-02 命令缓冲</a></li><li class="chapter-item expanded "><a href="../../04 画一个三角形 Drawing a triangle/04-04 绘制 Drawing/04-04-03 渲染与显示 Rendering and presentation.html"><strong aria-hidden="true">17.</strong> 04-04-03 渲染与显示</a></li><li class="chapter-item expanded affix "><li class="part-title">05 顶点缓冲 Vertex buffers</li><li class="chapter-item expanded "><a href="../../05 顶点缓冲 Vertex buffers/05-01 顶点输入描述 Vertex input description.html"><strong aria-hidden="true">18.</strong> 05-01 顶点输入描述</a></li><li class="chapter-item expanded "><a href="../../05 顶点缓冲 Vertex buffers/05-02 创建顶点缓冲 Vertex buffer creation.html"><strong aria-hidden="true">19.</strong> 05-02 创建顶点缓冲</a></li><li class="chapter-item expanded "><a href="../../05 顶点缓冲 Vertex buffers/05-03 暂存缓冲 Staging buffer.html"><strong aria-hidden="true">20.</strong> 05-03 暂存缓冲</a></li><li class="chapter-item expanded "><a href="../../05 顶点缓冲 Vertex buffers/05-04 索引缓冲 Index buffer.html"><strong aria-hidden="true">21.</strong> 05-04 索引缓冲</a></li><li class="chapter-item expanded affix "><li class="part-title">06 Uniform缓冲 Uniform Buffers</li><li class="chapter-item expanded "><a href="../../06 Uniform缓冲 Uniform Buffers/06-01 描述符布局与描述符缓冲 Descriptor layout and buffer.html"><strong aria-hidden="true">22.</strong> 06-01 描述符布局与描述符缓冲</a></li><li class="chapter-item expanded "><a href="../../06 Uniform缓冲 Uniform Buffers/06-02 描述符池与描述符集合 Descriptor pool and sets.html"><strong aria-hidden="true">23.</strong> 06-02 描述符池与描述符集合</a></li><li class="chapter-item expanded affix "><li class="part-title">07 纹理映射 Texture mapping</li><li class="chapter-item expanded "><a href="../../07 纹理映射 Texture mapping/07-01 图像 Images.html"><strong aria-hidden="true">24.</strong> 07-01 图像</a></li><li class="chapter-item expanded "><a href="../../07 纹理映射 Texture mapping/07-02 图像视图与采样器 Image view and sample.html"><strong aria-hidden="true">25.</strong> 07-02 图像视图与采样器</a></li><li class="chapter-item expanded "><a href="../../07 纹理映射 Texture mapping/07-03 组合图像采样器 Combined image sampler.html"><strong aria-hidden="true">26.</strong> 07-03 组合图像采样器</a></li><li class="chapter-item expanded "><a href="../../08 深度缓冲 Depth buffering.html"><strong aria-hidden="true">27.</strong> 08 深度缓冲</a></li><li class="chapter-item expanded "><a href="../../09 加载模型 Loading models.html"><strong aria-hidden="true">28.</strong> 09 加载模型</a></li><li class="chapter-item expanded "><a href="../../10 生成多级渐远纹理 Generating Mipmaps.html"><strong aria-hidden="true">29.</strong> 10 生成多级渐远纹理</a></li><li class="chapter-item expanded "><a href="../../11 多重采样 Multisampling.html"><strong aria-hidden="true">30.</strong> 11 多重采样</a></li><li class="chapter-item expanded "><a href="../../12 常见问题 FAQ.html"><strong aria-hidden="true">31.</strong> 12 常见问题</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="验证层"><a class="header" href="#验证层">验证层</a></h1>
<h2 id="验证层是什么"><a class="header" href="#验证层是什么">验证层是什么？</a></h2>
<p>Vulkan API是基于最小化驱动负担的思想设计的，这个目标的一个体现形式就是，在默认情况下，这套API中的错误检查十分受限。哪怕是一点小问题，比如枚举值传错了，或者在必需参数上传了一个空指针，通常都没办法被显式处理，并且很容易导致崩溃或者未定义行为。由于Vulkan要求你在使用时显式设置每样东西，就会很容易导致许多小毛病的发生：比如使用了新的GPU特性却没有在创建逻辑设备的时候请求它。</p>
<p>然而，这并不意味着不能给这套API加上错误检查。Vulkan使用了一个非常优雅的系统来进行错误检查，这就是“验证层”（validation layers）。验证层是一些连接在Vulkan函数上的可选组件，用来进行一些额外的操作。一般来说，验证层有以下用途：</p>
<ul>
<li>根据规范检测参数值，以避免误用</li>
<li>追踪对象的创建和析构过程，以发现资源泄露</li>
<li>从一个线程被调用的源头追踪线程，以检查线程安全性</li>
<li>把每个调用及其参数都记录在标准输出上</li>
<li>追踪Vulkan函数的调用，以进行性能分析和重放</li>
</ul>
<p>以下是诊断验证层（diagnostics validation layer）的一个函数实例：</p>
<pre><code class="language-cpp">VkResult vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* instance) {

    if (pCreateInfo == nullptr || instance == nullptr) {
        log(&quot;Null pointer passed to required parameter!&quot;);
        return VK_ERROR_INITIALIZATION_FAILED;
    }

    return real_vkCreateInstance(pCreateInfo, pAllocator, instance);
}

</code></pre>
<p>这些验证层可以自由地组合起来，以实现你感兴趣的所有调试功能。你可以简单地在调试时开启验证层，然后在发布时彻底关掉验证层，这样两全其美。</p>
<p>Vulkan没有任何内置的验证层，但是LunarG Vulkan SDK提供了一套验证层来检查普通的错误。这些验证层是完全<a href="https://github.com/KhronosGroup/Vulkan-ValidationLayers">开源</a>的，所以你可以看到它们都检查和贡献的错误类型。使用验证层是避免你的应用程序因不小心依赖未定义行为而在不同的驱动上崩溃的最佳方式。</p>
<p>验证层只有在安装在系统上之后才能使用。举个例子，LunarG验证层只能在装了Vulkan SDK的电脑上使用。</p>
<p>Vulkan中曾经有两种不同类型的验证层：实例验证层和基于特定设备的验证层。这种想法是实例层只检查与全局Vulkan对象有关的调用，比如实例；而基于特定设备的验证层则只检查与某种特定GPU有关的调用。基于特定设备的验证层现在已经被弃用，这意味着实例验证层可以作用于所有Vulkan调用。规范文档仍然推荐你同时在设备层面启用验证层以提高兼容性，这是某些实现所需要的。我们将简单地在逻辑设备层面启用一些和实例层面相同的验证层，我们一会儿会讨论这个。</p>
<h2 id="使用验证层"><a class="header" href="#使用验证层">使用验证层</a></h2>
<p>在这一节我们会看看如何启用一个Vulkan SDK提供的标准诊断层。和扩展一样，验证层也需要通过指定名字的方式启用。不需要显式指定所有可用的层，SDK允许你请求<code>VK_LAYER_LUNARG_standard_validation</code>层来隐式启用大部分可用的诊断层。</p>
<p>首先在程序里加两个配置变量来指定要启用的层，以及是否启用它们。我选择了让这个值基于调试模式是否开启。<code>NDEBUG</code>宏是C++标准的一部分，代表着“没有进行调试”。</p>
<pre><code class="language-c++">const int WIDTH = 800;
const int HEIGHT = 600;

const std::vector&lt;const char*&gt; validationLayers = {
    &quot;VK_LAYER_LUNARG_standard_validation&quot;
};

#ifdef NDEBUG
    const bool enableValidationLayers = false;
#else
    const bool enableValidationLayers = true;
#endif
</code></pre>
<p>我们添加了一个新函数<code>checkValidationLayerSupport</code>来检查是否所有被请求的层都可用。首先使用<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkEnumerateInstanceLayerProperties.html"><code>vkEnumerateInstanceLayerProperties</code></a>函数列出所有可用的层。这个函数的使用方式与之前讲解创建实例的时候使用的<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkEnumerateInstanceExtensionProperties.html"><code>vkEnumerateInstanceExtensionProperties</code></a>函数相同。</p>
<pre><code class="language-c++">bool checkValidationLayerSupport() {
    uint32_t layerCount;
    vkEnumerateInstanceLayerProperties(&amp;layerCount, nullptr);

    std::vector&lt;VkLayerProperties&gt; availableLayers(layerCount);
    vkEnumerateInstanceLayerProperties(&amp;layerCount, availableLayers.data());

    return false;
}
</code></pre>
<p>接下来，检查<code>validationLayers</code>中的层是否都存在于<code>availableLayers</code>列表里。你可能需要引入<code>&lt;cstring&gt;</code>头文件来使用<code>strcmp</code>。</p>
<pre><code class="language-c++">for (const char* layerName : validationLayers) {
    bool layerFound = false;

    for (const auto&amp; layerProperties : availableLayers) {
        if (strcmp(layerName, layerProperties.layerName) == 0) {
            layerFound = true;
            break;
        }
    }

    if (!layerFound) {
        return false;
    }
}

return true;
</code></pre>
<p>我们现在可以在<code>createInstance</code>中使用这个函数了：</p>
<pre><code class="language-c++">void createInstance() {
    if (enableValidationLayers &amp;&amp; !checkValidationLayerSupport()) {
        throw std::runtime_error(&quot;validation layers requested, but not available!&quot;);
    }

    ...
}
</code></pre>
<p>现在在调试模式下运行这个程序并且确保没有任何错误。如果出错了，确认一下你是否正确安装了Vulkan SDK。如果只报告了几个或者根本没有可用的层，那么你可能需要处理一下<a href="https://vulkan.lunarg.com/app/issues/578e8c8d5698c020d71580fc">这个问题</a>（需要一个LunarG 账号来查看）。查看这个页面来获得解决错误的帮助。</p>
<p>最后，修改<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkInstanceCreateInfo.html"><code>VkInstanceCreateInfo</code></a>结构体实例来引入可用的验证层名字：</p>
<pre><code class="language-c++">if (enableValidationLayers) {
    createInfo.enabledLayerCount = static_cast&lt;uint32_t&gt;(validationLayers.size());
    createInfo.ppEnabledLayerNames = validationLayers.data();
} else {
    createInfo.enabledLayerCount = 0;
}
</code></pre>
<p>如果检查成功了，那么<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>不应该返回<code>VK_ERROR_LAYER_NOT_PRESENT</code>错误，不过你应该运行一下程序来保证。</p>
<h2 id="信息回调函数"><a class="header" href="#信息回调函数">信息回调函数</a></h2>
<p>不幸的是，仅仅启用验证层的话没什么帮助，因为它们现在没有办法把错误信息发送回我们的程序。为了接收这些信息，我们需要设置一个回调函数，这需要<code>VK_EXT_debug_utils</code>插件。</p>
<p>首先我们创建一个<code>getRequiredExtensions</code>函数，这个函数将根据启用的验证层返回我们需要的插件列表：</p>
<pre><code class="language-c++">std::vector&lt;const char*&gt; getRequiredExtensions() {
    uint32_t glfwExtensionCount = 0;
    const char** glfwExtensions;
    glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);

    std::vector&lt;const char*&gt; extensions(glfwExtensions, glfwExtensions + glfwExtensionCount);

    if (enableValidationLayers) {
        extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
    }

    return extensions;
}
</code></pre>
<p>由GLFW指定的插件通常来说都是必需的，不过调试报告插件是有条件地加入的。注意一下此处我使用了<code>VK_EXT_DEBUG_UTILS_EXTENSION_NAME</code>宏，它等同于字面字符串&quot;VK_EXT_debug_utils&quot;。使用这个宏可以让你避免打错字。</p>
<p>现在我们可以在<code>createInstance</code>里面使用这个函数了：</p>
<pre><code class="language-c++">auto extensions = getRequiredExtensions();
createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(extensions.size());
createInfo.ppEnabledExtensionNames = extensions.data();
</code></pre>
<p>运行程序并且确保没有收到<code>VK_ERROR_EXTENSION_NOT_PRESENT</code>错误。我们实际上不用检查这个插件是否存在，因为验证层可用的话，它就是存在的。</p>
<p>现在我们来看看回调函数应该长什么样。加入一个名为<code>debugCallback</code>的新的静态成员函数并且使用<code>PFN_vkDebugUtilsMessengerCallbackEXT</code>函数原型。<code>VKAPI_ATTR</code>和<code>VKAPI_CALL</code> 确保了这个函数拥有正确的修饰符，以使Vulkan能够调用它。</p>
<pre><code class="language-c++">static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(
    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT messageType,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
    void* pUserData) {

    std::cerr &lt;&lt; &quot;validation layer: &quot; &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; std::endl;

    return VK_FALSE;
}
</code></pre>
<p>第一个参数指明了消息的严重性，其值是下列值之一：</p>
<ul>
<li><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT</code>：诊断消息</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT</code>：信息性消息，例如一个资源被创建</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT</code>：有关此消息的行为不一定是一个错误，但很有可能是应用程序中的一个bug（警告）</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT</code>：有关此消息的行为是非法的，并且可能导致程序崩溃（错误）</li>
</ul>
<p>这个枚举类型中的值是按照如上方式设置的，所以可以使用一个比较操作来检查一条消息是否与某个严重性相等或更加严重，例如：</p>
<pre><code class="language-c++">if (messageSeverity &gt;= VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {
    // Message is important enough to show
}
</code></pre>
<p><code>messageType</code>参数可以是以下值：</p>
<ul>
<li><code>VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT</code>：发生了一个与规范或性能无关的事件</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT</code>：发生了违反规范的行为或者有可能发生的错误</li>
<li><code>VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT</code>：潜在的Vulkan非最佳使用方式</li>
</ul>
<p><code>pCallbackData</code>参数是一个<code>VkDebugUtilsMessengerCallbackDataEXT</code>类型的结构体，其中包含了这个信息的细节，其中最重要的成员有：</p>
<ul>
<li><code>pMessage</code>：调试信息，是一个没有终止符的字符串</li>
<li><code>pObjects</code>：有关此消息的Vulkan对象句柄数组</li>
<li><code>objectCount</code>：数组中的对象数量</li>
</ul>
<p>最后，<code>pUserData</code>参数包含了一个在设置回调函数时指定的指针，允许你传入自己的数据。</p>
<p>回调函数返回一个布尔值指示当验证层消息被Vulkan函数调用触发时是否应该退出程序。如果回调函数返回了真值，这个调用就会以<code>VK_ERROR_VALIDATION_FAILED_EXT</code>错误退出。这通常只用于测试验证层本身，因此你应该始终返回<code>VK_FALSE</code>。</p>
<p>现在只剩下告知Vulkan有关这个回调函数的信息。说起来或许会有些令人惊讶，就连Vulkan中的调试回调函数也由一个需要显式创建和销毁的句柄来管理。这种回调函数被称为“messenger”，并且你可以根据需要想设置多少个就设置多少个。在<code>instance</code>下方添加一个类成员来保存这个句柄：</p>
<pre><code class="language-c++">VkDebugUtilsMessengerEXT callback;
</code></pre>
<p>现在添加一个<code>setupDebugCallback</code>函数，然后在<code>initVulkan</code>中的<code>createInstance</code>之后调用：</p>
<pre><code class="language-c++">void initVulkan() {
    createInstance();
    setupDebugCallback();
}

void setupDebugCallback() {
    if (!enableValidationLayers) return;

}
</code></pre>
<p>我们现在需要用这个回调函数的细节来填充一个结构体：</p>
<pre><code class="language-c++">VkDebugUtilsMessengerCreateInfoEXT createInfo = {};
createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
createInfo.pfnUserCallback = debugCallback;
createInfo.pUserData = nullptr; // Optional
</code></pre>
<p><code>messageSeverity</code>字段允许你指定你的回调函数在何种严重等级下被触发。我在此指定了除<code>VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT</code>以外的所有等级来接收所有可能的错误信息并忽略一般的调试信息。</p>
<p>类似地，<code>messageType</code>字段允许你过滤回调函数的消息类型。我在这里简单地开启了所有类型，你可以关闭那些对你来说没什么用的。</p>
<p>最后，<code>pfnUserCallback</code>指定了回调函数的指针。你可以给<code>pUserData</code>传递一个指针，这个指针会通过<code>pUserData</code>参数传递到回调函数中。比如你可以用这个来传递<code>HelloTriangleApplication</code>类的指针。</p>
<p>注意，配置验证层消息和调试回调函数还有很多不同的方法，不过这里给出的是一个很适合入门的方法。关于其它方法，参阅<a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_debug_utils">extension specification</a>（扩展规范）以获取更多信息。</p>
<p>这个结构体应该被传递到<code>vkCreateDebugUtilsMessengerEXT</code>函数中来创建<code>VkDebugUtilsMessengerEXT</code>对象。不幸的是，因为这个函数是一个扩展函数，所以它不会被自动加载。我们必须自己用<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkGetInstanceProcAddr</code></a>函数来查找它的地址。我们要创建一个我们自己的代理函数，帮助我们在后天完成这一切。我在<code>HelloTriangleApplication</code>类定义的上面添加了这个函数：</p>
<pre><code class="language-c++">VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pCallback) {
    auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, &quot;vkCreateDebugUtilsMessengerEXT&quot;);
    if (func != nullptr) {
        return func(instance, pCreateInfo, pAllocator, pCallback);
    } else {
        return VK_ERROR_EXTENSION_NOT_PRESENT;
    }
}
</code></pre>
<p>如果这个函数没有被加载，<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkGetInstanceProcAddr</code></a>函数则返回<code>nullptr</code>。现在，如果该函数可用，我们就可以调用这个函数来创建这个扩展对象了：</p>
<pre><code class="language-c++">if (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, nullptr, &amp;callback) != VK_SUCCESS) {
    throw std::runtime_error(&quot;failed to set up debug callback!&quot;);
}
</code></pre>
<p>倒数第二个参数依然是那个被我们设置成<code>nullptr</code>的可选的分配器回调函数，其余的参数含义都很明了。由于调试回调函数特定于我们的Vulkan实例和它的验证层，它们需要被显式设置为第一个参数。一会你还会看到这种模式用在其它“子”对象上。让我们看看它是否正常工作……运行程序，然后在你看腻了那个空白窗口之后关掉它。你应该看到如下消息被打印在命令提示符上：</p>
<p><img src="https://vulkan-tutorial.com/images/validation_layer_test.png" alt="" /></p>
<p>哎呀，在我们的程序中已经发现了一个bug！<code>VkDebugUtilsMessengerEXT</code>对象需要被<code>vkDestroyDebugUtilsMessengerEXT</code>函数清除。与<code>vkCreateDebugUtilsMessengerEXT</code> 类似，这个函数需要被显式加载。注意一下，消息被打印很多是正常的，因为有复数个验证层在检查调试messenger是否被删除。</p>
<p>在<code>CreateDebugUtilsMessengerEXT</code>下面添加另外一个代理函数：</p>
<pre><code class="language-c++">void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT callback, const VkAllocationCallbacks* pAllocator) {
    auto func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, &quot;vkDestroyDebugUtilsMessengerEXT&quot;);
    if (func != nullptr) {
        func(instance, callback, pAllocator);
    }
}
</code></pre>
<p>确保这个函数是一个静态成员函数，或者是一个类外面的函数。这样我们可以在<code>cleanup</code>函数中调用它：</p>
<pre><code class="language-c++">void cleanup() {
    if (enableValidationLayers) {
        DestroyDebugUtilsMessengerEXT(instance, callback, nullptr);
    }

    vkDestroyInstance(instance, nullptr);

    glfwDestroyWindow(window);

    glfwTerminate();
}
</code></pre>
<p>当你运行程序的时候，你将不会看到任何错误消息。如果你想看到哪个调用触发了消息，你可以在消息回调函数里打一个断点，然后看看堆栈跟踪。</p>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>除了在<code>VkDebugUtilsMessengerCreateInfoEXT</code>结构体中指定标志之外，还有很多设置验证层行为的方法，浏览Vulkan SDK中的<code>Config</code>目录，<code>vk_layer_settings.txt</code> 文件解释了如何设置这些验证层。</p>
<p>要为你的应用程序设置验证层，把这个文件复制到你工程的<code>Debug</code>和<code>Release</code>文件夹里然后照着上面的说明来设置你想要的行为。然而，在此教程的余下部分，我假设你用的是默认设置。</p>
<p>在此教程中，我会故意犯几个错误来让你看看验证层对于捕获这些错误有多大的帮助，并且告诉你清楚地知道你在用Vulkan做什么有多重要。现在是时候看看系统中的Vulkan设备了。</p>
<p><a href="https://vulkan-tutorial.com/code/02_validation_layers.cpp">C++代码</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../04 画一个三角形 Drawing a triangle/04-01 建立 Setup/04-01-02 实例 Instance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../04 画一个三角形 Drawing a triangle/04-01 建立 Setup/04-01-04 物理设备与队列家族 Physical devices and queue families.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../04 画一个三角形 Drawing a triangle/04-01 建立 Setup/04-01-02 实例 Instance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../04 画一个三角形 Drawing a triangle/04-01 建立 Setup/04-01-04 物理设备与队列家族 Physical devices and queue families.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
